{
  "question_id": null,
  "course": "ST2137",
  "semester": 2510,
  "assessment_type": "final",
  "question_no": 2,
  "is_multi": false,
  "question_stem": "An improvement on the Jaccard index (for measuring similarity between sets) is the weighted Jaccard Index. It takes into account the count of the items in each set. Here is how it is computed:\n\nCreate a vector for each set, tabulating the count for each item type. Let these vectors be X and Y.\nCompute the weighted Jaccard similarity as ∑imin(Xi,Yi)∑imax(Xi,Yi) Here is an example using the following sets:\n\nl1 = ['apple', 'apple', 'orange', 'durian', 'durian', 'mango']\nl2 = ['apple', 'orange', 'orange', 'durian']\nThen X counts the number of times l1 contains apple, orange, durian and mango in that order: X=[2,1,2,1] Y contains the counts for l2: Y=[1,2,1,0] Then the weighted Jaccard similarity is: 1+1+1+02+2+2+1=37 Fill in the blanks to finish the code for an implementation in Python:\ndef weighted_jacc(list1, list2):\n    # Obtain counts from each set:\n    A = pd.Series(list1).___________\n    B = pd.Series(list2).___________\n    \n    df1 = pd.DataFrame({'x':A, 'y':B})\n    \n    # Replace missing values in df1 with 0:\n    _______ = df1.fillna(0)\n    \n    # Compute and return numerator/denominator:\n    ____________    ____________",
  "question_stem_html": "<div><p>An improvement on the Jaccard index (for measuring similarity between sets) is the weighted Jaccard Index. It takes into account the count of the items in each set. Here is how it is computed:</p>\n<ol style=\"list-style-type: decimal;\">\n<li>Create a vector for each set, tabulating the count for each item type. Let these vectors be <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>X</mi></semantics></math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>Y</mi></semantics></math>.</li>\n<li>Compute the weighted Jaccard similarity as <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><mo>min</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow><mrow><munder><mo>∑</mo><mi>i</mi></munder><mo>max</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow></mfrac></semantics></math> Here is an example using the following sets:</li>\n</ol>\n<pre><code>l1 = ['apple', 'apple', 'orange', 'durian', 'durian', 'mango']\nl2 = ['apple', 'orange', 'orange', 'durian']</code></pre>\n<p>Then <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>X</mi></semantics></math> counts the number of times <code>l1</code> contains <code>apple</code>, <code>orange</code>, <code>durian</code> and <code>mango</code> in that order: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>X</mi><mo>=</mo><mrow><mo form=\"prefix\" stretchy=\"true\">[</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo form=\"postfix\" stretchy=\"true\">]</mo></mrow></mrow></semantics></math> <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>Y</mi></semantics></math> contains the counts for <code>l2</code>: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>Y</mi><mo>=</mo><mrow><mo form=\"prefix\" stretchy=\"true\">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo form=\"postfix\" stretchy=\"true\">]</mo></mrow></mrow></semantics></math> Then the weighted Jaccard similarity is: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>0</mn></mrow><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>7</mn></mfrac></mrow></semantics></math> Fill in the blanks to finish the code for an implementation in Python:</p>\n<pre><code>def weighted_jacc(list1, list2):\n    # Obtain counts from each set:\n    A = pd.Series(list1).___________\n    B = pd.Series(list2).___________\n    \n    df1 = pd.DataFrame({'x':A, 'y':B})\n    \n    # Replace missing values in df1 with 0:\n    _______ = df1.fillna(0)\n    \n    # Compute and return numerator/denominator:\n    ____________<br><br>    ____________</code></pre></div>",
  "version": 1,
  "update_timestamp": "2025-09-17T22:44:12+08:00",
  "question_media": [],
  "items": [
    {
      "part_number": "a",
      "type": "essay",
      "subtype": "open-ended",
      "part_stem": "An improvement on the Jaccard index (for measuring similarity between sets) is the weighted Jaccard Index. It takes into account the count of the items in each set. Here is how it is computed:\n\nCreate a vector for each set, tabulating the count for each item type. Let these vectors be X and Y.\nCompute the weighted Jaccard similarity as ∑imin(Xi,Yi)∑imax(Xi,Yi) Here is an example using the following sets:\n\nl1 = ['apple', 'apple', 'orange', 'durian', 'durian', 'mango']\nl2 = ['apple', 'orange', 'orange', 'durian']\nThen X counts the number of times l1 contains apple, orange, durian and mango in that order: X=[2,1,2,1] Y contains the counts for l2: Y=[1,2,1,0] Then the weighted Jaccard similarity is: 1+1+1+02+2+2+1=37 Fill in the blanks to finish the code for an implementation in Python:\ndef weighted_jacc(list1, list2):\n    # Obtain counts from each set:\n    A = pd.Series(list1).___________\n    B = pd.Series(list2).___________\n    \n    df1 = pd.DataFrame({'x':A, 'y':B})\n    \n    # Replace missing values in df1 with 0:\n    _______ = df1.fillna(0)\n    \n    # Compute and return numerator/denominator:\n    ____________    ____________",
      "part_stem_html": "<div><p>An improvement on the Jaccard index (for measuring similarity between sets) is the weighted Jaccard Index. It takes into account the count of the items in each set. Here is how it is computed:</p>\n<ol style=\"list-style-type: decimal;\">\n<li>Create a vector for each set, tabulating the count for each item type. Let these vectors be <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>X</mi></semantics></math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>Y</mi></semantics></math>.</li>\n<li>Compute the weighted Jaccard similarity as <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><mo>min</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow><mrow><munder><mo>∑</mo><mi>i</mi></munder><mo>max</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow></mfrac></semantics></math> Here is an example using the following sets:</li>\n</ol>\n<pre><code>l1 = ['apple', 'apple', 'orange', 'durian', 'durian', 'mango']\nl2 = ['apple', 'orange', 'orange', 'durian']</code></pre>\n<p>Then <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>X</mi></semantics></math> counts the number of times <code>l1</code> contains <code>apple</code>, <code>orange</code>, <code>durian</code> and <code>mango</code> in that order: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>X</mi><mo>=</mo><mrow><mo form=\"prefix\" stretchy=\"true\">[</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo form=\"postfix\" stretchy=\"true\">]</mo></mrow></mrow></semantics></math> <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mi>Y</mi></semantics></math> contains the counts for <code>l2</code>: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>Y</mi><mo>=</mo><mrow><mo form=\"prefix\" stretchy=\"true\">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo form=\"postfix\" stretchy=\"true\">]</mo></mrow></mrow></semantics></math> Then the weighted Jaccard similarity is: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>0</mn></mrow><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>7</mn></mfrac></mrow></semantics></math> Fill in the blanks to finish the code for an implementation in Python:</p>\n<pre><code>def weighted_jacc(list1, list2):\n    # Obtain counts from each set:\n    A = pd.Series(list1).___________\n    B = pd.Series(list2).___________\n    \n    df1 = pd.DataFrame({'x':A, 'y':B})\n    \n    # Replace missing values in df1 with 0:\n    _______ = df1.fillna(0)\n    \n    # Compute and return numerator/denominator:\n    ____________<br><br>    ____________</code></pre></div>",
      "choices": [
        {
          "choice_id": "Your answer",
          "text": "text_str",
          "text_html": "<p>text_str</p>",
          "is_correct": null,
          "explanation": null
        }
      ],
      "items_media": [],
      "scoring": {
        "points": 1.0
      },
      "feedback": {},
      "shuffle_choices": false,
      "solution": "def weighted_jacc(list1, list2):\n    A = pd.Series(list1).value_counts()\n    B = pd.Series(list2).value_counts()\n    df1 = pd.DataFrame({'x':A, 'y':B})\n    df1.fillna(0, inplace=True)\n    print(df1)\n    return df1.min(axis=1).sum() / df1.max(axis=1).sum()",
      "solution_html": "<pre><code>def weighted_jacc(list1, list2):\n    A = pd.Series(list1).value_counts()\n    B = pd.Series(list2).value_counts()\n    df1 = pd.DataFrame({'x':A, 'y':B})\n    df1.fillna(0, inplace=True)\n    print(df1)\n    return df1.min(axis=1).sum() / df1.max(axis=1).sum()</code></pre>",
      "difficulty_level": 1.0,
      "concept_tags": [
        "probability"
      ]
    }
  ]
}