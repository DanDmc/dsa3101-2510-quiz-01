{
  "question_id": null,
  "course": "ST2137",
  "semester": 2510,
  "assessment_type": "midterm",
  "question_no": 14,
  "is_multi": false,
  "question_stem": "This question is to be answered using R.\nThe purpose of the Box-Muller algorithm is to generate pairs of random variables from the standard Normal distribution. Here is how it works:\n\nGenerate two independent random variables U1U_1 and U2U_2 from the Uniform(0,1) distribution.\nCompute the following two random variables: Z1=−2log(U1)cos(2πU2)Z2=−2log(U1)sin(2πU2)\\begin{eqnarray*} Z_1 &=& \\sqrt{-2 \\log(U_1)} \\cos(2 \\pi U_2) \\\\ Z_2 &=& \\sqrt{-2 \\log(U_1)} \\sin(2 \\pi U_2) \\end{eqnarray*}\n\nThen Z1Z_1 and Z2Z_2 are independent random variables from the standard Normal distribution.\n\nWrite a function in R that will take an even number n as input and return a vector of 2n standard Normal random variables.\nUse your function in a simulation study (with sample sizes equals to 30) to assess if the Shapiro-Wilk test will indeed reject the observations from the above algorithm 10% of the time, when testing at α=0.1\\alpha=0.1.",
  "question_stem_html": "<div><p> </p>\n<p>This question is to be answered using R.</p>\n<p>The purpose of the Box-Muller algorithm is to generate pairs of random variables from the standard Normal distribution. Here is how it works:</p>\n<ol style=\"list-style-type: decimal;\">\n<li>Generate two independent random variables <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>U</mi><mn>1</mn></msub><annotation encoding=\"application/x-tex\">U_1</annotation></semantics></math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>U</mi><mn>2</mn></msub><annotation encoding=\"application/x-tex\">U_2</annotation></semantics></math> from the Uniform(0,1) distribution.</li>\n<li>Compute the following two random variables: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable><mtr><mtd style=\"text-align: right;\" columnalign=\"right\"><msub><mi>Z</mi><mn>1</mn></msub></mtd><mtd style=\"text-align: center;\" columnalign=\"center\"><mo>=</mo></mtd><mtd style=\"text-align: left;\" columnalign=\"left\"><msqrt><mrow><mo>−</mo><mn>2</mn><mo>log</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow></msqrt><mo>cos</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><mn>2</mn><mi>π</mi><msub><mi>U</mi><mn>2</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mtd></mtr><mtr><mtd style=\"text-align: right;\" columnalign=\"right\"><msub><mi>Z</mi><mn>2</mn></msub></mtd><mtd style=\"text-align: center;\" columnalign=\"center\"><mo>=</mo></mtd><mtd style=\"text-align: left;\" columnalign=\"left\"><msqrt><mrow><mo>−</mo><mn>2</mn><mo>log</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow></msqrt><mo>sin</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><mn>2</mn><mi>π</mi><msub><mi>U</mi><mn>2</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{eqnarray*} Z_1 &=& \\sqrt{-2 \\log(U_1)} \\cos(2 \\pi U_2) \\\\ Z_2 &=& \\sqrt{-2 \\log(U_1)} \\sin(2 \\pi U_2) \\end{eqnarray*}</annotation></semantics></math></li>\n</ol>\n<p>Then <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>Z</mi><mn>1</mn></msub><annotation encoding=\"application/x-tex\">Z_1</annotation></semantics></math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>Z</mi><mn>2</mn></msub><annotation encoding=\"application/x-tex\">Z_2</annotation></semantics></math> are independent random variables from the standard Normal distribution.</p>\n<ol style=\"list-style-type: decimal;\">\n<li>Write a function in R that will take an even number <code>n</code> as input and return a <em>vector</em> of <code>2n</code> standard Normal random variables.</li>\n<li>Use your function in a simulation study (with sample sizes equals to 30) to assess if the Shapiro-Wilk test will indeed reject the observations from the above algorithm 10% of the time, when testing at <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha=0.1</annotation></semantics></math>.</li>\n</ol>\n<p><br><br><br></p></div>",
  "version": 1,
  "update_timestamp": "2025-09-17T22:44:01+08:00",
  "question_media": [],
  "items": [
    {
      "part_number": "a",
      "type": "essay",
      "subtype": "open-ended",
      "part_stem": "This question is to be answered using R.\nThe purpose of the Box-Muller algorithm is to generate pairs of random variables from the standard Normal distribution. Here is how it works:\n\nGenerate two independent random variables U1U_1 and U2U_2 from the Uniform(0,1) distribution.\nCompute the following two random variables: Z1=−2log(U1)cos(2πU2)Z2=−2log(U1)sin(2πU2)\\begin{eqnarray*} Z_1 &=& \\sqrt{-2 \\log(U_1)} \\cos(2 \\pi U_2) \\\\ Z_2 &=& \\sqrt{-2 \\log(U_1)} \\sin(2 \\pi U_2) \\end{eqnarray*}\n\nThen Z1Z_1 and Z2Z_2 are independent random variables from the standard Normal distribution.\n\nWrite a function in R that will take an even number n as input and return a vector of 2n standard Normal random variables.\nUse your function in a simulation study (with sample sizes equals to 30) to assess if the Shapiro-Wilk test will indeed reject the observations from the above algorithm 10% of the time, when testing at α=0.1\\alpha=0.1.",
      "part_stem_html": "<div><p> </p>\n<p>This question is to be answered using R.</p>\n<p>The purpose of the Box-Muller algorithm is to generate pairs of random variables from the standard Normal distribution. Here is how it works:</p>\n<ol style=\"list-style-type: decimal;\">\n<li>Generate two independent random variables <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>U</mi><mn>1</mn></msub><annotation encoding=\"application/x-tex\">U_1</annotation></semantics></math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>U</mi><mn>2</mn></msub><annotation encoding=\"application/x-tex\">U_2</annotation></semantics></math> from the Uniform(0,1) distribution.</li>\n<li>Compute the following two random variables: <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable><mtr><mtd style=\"text-align: right;\" columnalign=\"right\"><msub><mi>Z</mi><mn>1</mn></msub></mtd><mtd style=\"text-align: center;\" columnalign=\"center\"><mo>=</mo></mtd><mtd style=\"text-align: left;\" columnalign=\"left\"><msqrt><mrow><mo>−</mo><mn>2</mn><mo>log</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow></msqrt><mo>cos</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><mn>2</mn><mi>π</mi><msub><mi>U</mi><mn>2</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mtd></mtr><mtr><mtd style=\"text-align: right;\" columnalign=\"right\"><msub><mi>Z</mi><mn>2</mn></msub></mtd><mtd style=\"text-align: center;\" columnalign=\"center\"><mo>=</mo></mtd><mtd style=\"text-align: left;\" columnalign=\"left\"><msqrt><mrow><mo>−</mo><mn>2</mn><mo>log</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mrow></msqrt><mo>sin</mo><mrow><mo form=\"prefix\" stretchy=\"true\">(</mo><mn>2</mn><mi>π</mi><msub><mi>U</mi><mn>2</mn></msub><mo form=\"postfix\" stretchy=\"true\">)</mo></mrow></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{eqnarray*} Z_1 &=& \\sqrt{-2 \\log(U_1)} \\cos(2 \\pi U_2) \\\\ Z_2 &=& \\sqrt{-2 \\log(U_1)} \\sin(2 \\pi U_2) \\end{eqnarray*}</annotation></semantics></math></li>\n</ol>\n<p>Then <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>Z</mi><mn>1</mn></msub><annotation encoding=\"application/x-tex\">Z_1</annotation></semantics></math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><msub><mi>Z</mi><mn>2</mn></msub><annotation encoding=\"application/x-tex\">Z_2</annotation></semantics></math> are independent random variables from the standard Normal distribution.</p>\n<ol style=\"list-style-type: decimal;\">\n<li>Write a function in R that will take an even number <code>n</code> as input and return a <em>vector</em> of <code>2n</code> standard Normal random variables.</li>\n<li>Use your function in a simulation study (with sample sizes equals to 30) to assess if the Shapiro-Wilk test will indeed reject the observations from the above algorithm 10% of the time, when testing at <math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha=0.1</annotation></semantics></math>.</li>\n</ol>\n<p><br><br><br></p></div>",
      "choices": [
        {
          "choice_id": "Your answer",
          "text": "text_str",
          "text_html": "<p>text_str</p>",
          "is_correct": null,
          "explanation": null
        }
      ],
      "items_media": [],
      "scoring": {
        "points": 1.0
      },
      "feedback": {},
      "shuffle_choices": false,
      "solution": "box_muller \nset.seed(123)\nn_size \n## [1] 0.0896844 0.1283156\n\nbox_muller \nset.seed(123)\nn_size \n## [1] 0.0896844 0.1283156\n\nbox_muller \nset.seed(123)\nn_size \n## [1] 0.0896844 0.1283156",
      "solution_html": "<pre><code>box_muller <- function(n) {\n  u1 <- runif(n)\n  u2 <- runif(n)\n  z1 <- sqrt(-2 * log(u1)) * cos(2 * pi * u2)\n  z2 <- sqrt(-2 * log(u1)) * sin(2 * pi * u2)\n  return(c(z1, z2))\n}</code></pre>\n<pre><code>set.seed(123)\nn_size <- 30\nalpha <- 0.1\noutput <- rep(0, 1000)\nfor(i in 1:1000){\n  X <- box_muller(n_size)\n  test_out <- ks.test(X, \"pnorm\")$p.value\n  if(test_out < alpha){\n    output[i] <- 1\n  } else {\n    output[i] <- 0\n  }\n}\n# Report CI\np_est <- mean(output)\nlower_ci <- p_est - 1.96*sqrt(p_est*(1-p_est)/1000)\nupper_ci <- p_est + 1.96*sqrt(p_est*(1-p_est)/1000)\nc(lower_ci, upper_ci)</code></pre>\n<pre><code>## [1] 0.0896844 0.1283156</code></pre>\n\n<pre><code>box_muller <- function(n) {\n  u1 <- runif(n)\n  u2 <- runif(n)\n  z1 <- sqrt(-2 * log(u1)) * cos(2 * pi * u2)\n  z2 <- sqrt(-2 * log(u1)) * sin(2 * pi * u2)\n  return(c(z1, z2))\n}</code></pre>\n<pre><code>set.seed(123)\nn_size <- 30\nalpha <- 0.1\noutput <- rep(0, 1000)\nfor(i in 1:1000){\n  X <- box_muller(n_size)\n  test_out <- ks.test(X, \"pnorm\")$p.value\n  if(test_out < alpha){\n    output[i] <- 1\n  } else {\n    output[i] <- 0\n  }\n}\n# Report CI\np_est <- mean(output)\nlower_ci <- p_est - 1.96*sqrt(p_est*(1-p_est)/1000)\nupper_ci <- p_est + 1.96*sqrt(p_est*(1-p_est)/1000)\nc(lower_ci, upper_ci)</code></pre>\n<pre><code>## [1] 0.0896844 0.1283156</code></pre>\n\n<pre><code>box_muller <- function(n) {\n  u1 <- runif(n)\n  u2 <- runif(n)\n  z1 <- sqrt(-2 * log(u1)) * cos(2 * pi * u2)\n  z2 <- sqrt(-2 * log(u1)) * sin(2 * pi * u2)\n  return(c(z1, z2))\n}</code></pre>\n<pre><code>set.seed(123)\nn_size <- 30\nalpha <- 0.1\noutput <- rep(0, 1000)\nfor(i in 1:1000){\n  X <- box_muller(n_size)\n  test_out <- ks.test(X, \"pnorm\")$p.value\n  if(test_out < alpha){\n    output[i] <- 1\n  } else {\n    output[i] <- 0\n  }\n}\n# Report CI\np_est <- mean(output)\nlower_ci <- p_est - 1.96*sqrt(p_est*(1-p_est)/1000)\nupper_ci <- p_est + 1.96*sqrt(p_est*(1-p_est)/1000)\nc(lower_ci, upper_ci)</code></pre>\n<pre><code>## [1] 0.0896844 0.1283156</code></pre>",
      "difficulty_level": 1.0,
      "concept_tags": [
        "probability"
      ]
    }
  ]
}